{"pageProps":{"postData":{"id":"the-problem-with-software-methodologies","content":"\r\nBoris Demko was an incredible programmer. With 35 years of experience under his belt, Boris had\r\ndone it all. He'd written professional-grade compilers, renderers, databases, and neural networks.\r\nHe'd lead the engineering effort at several large tech companies while they\r\nwere working on their flagship products. Even his side-project programming language, BorisC, would\r\ngo on to accumulate 50k GitHub stars and thousands of users. Having immense experience in the\r\nsuccessful delivery of software, Boris decided he would distill his software development and project\r\nmanagement methodology into a simple 25-part process known as \"Borisgile\". Once published, the\r\nBorisgile manifesto (a book detailing the Borisgile methodology) instantly climbed to number\r\none on HackerNews. The printed version became the best seller in Amazon's Computer and\r\nTechnology book department. Developers across the globe began practicing Borisgile and preaching\r\nits benefits. Just about every major city began hosting weekly Borisgile meetups, where evangelists\r\nand newcomers alike would sit around and discuss their new religion. All the major tech companies\r\nbegan adopting the Borisgile methodology. From now on, all code was to be written in groups of 3,\r\na strategy defined in Borisgile as \"triplet programming\".\r\n1 and 2 week development cycles were overhauled and replaced with the flashy new \"marathon\", a unit\r\nof time defined in Borisgile as 36 hours straight of fingers-to-keyboard. Task\r\nestimation exercises like Planning Poker were replaced with their Borisgile equivalent:\r\nPlanning Shots. In planning shots, team members, each of which is equipped with a bottle of Vodka,\r\ngo through their backlog items 1-by-1 and estimate how many marathons each task will take. The catch\r\nis that you have to take 1 shot for every marathon point you estimate.\r\nSo to estimate that a task will take 2 marathons to complete, you'd have to take 2 shots of vodka.\r\n\r\nTo the surprise of the major tech companies, the introduction of Borisgile didn't improve the\r\niteration speed and quality of their software. In fact, it decreased it. Immensely. How could this\r\nbe? The great Boris Demko used Borisgile to ship quality software in record time. Evangelists across\r\nthe internet swore by its efficacy. Things just didn't add up.\r\n\r\nWe naively expect methodologies to provide cookie-cutter solutions to hard problems in complex\r\ndomains. We deceive ourselves with lies like \"I'll finish this in time If I work in 2-week sprints\",\r\nor \"My software will be reliable if I write my tests first\". Just because methodologies _can_ lead\r\nto improvements doesn't mean they're _guaranteed_ to. Software is complex.\r\nEvery problem and every project is unique. And no methodology, no matter how thorough, can\r\nencapsulate and provide instructions for all of the possible issues we'll face. We have to think\r\ncritically to write good software in a timely manner. The moment we begin suspending our critical\r\nthinking in favor of memorized processes from the hottest new methodology is the moment our quality\r\nand iteration speed begin to slip. The problem with methodologies is that they undermine the\r\nimportance of individual competence. And we're desperate enough to believe them.\r\n\r\nA talented team of developers following no particular methodology will run circles around an\r\ninexperienced team practicing strict Agile. Similar to how a random mix of NBA players with no\r\nset offense will absolutely pummel a team of high-schoolers running the world's best offense.\r\nBut we're so desperate for a sure thing, a solution to a hard problem without putting in the hard\r\nwork, that we deceive ourselves into believing that an intricate system with fancy\r\nterminology will make up for our lack of experience. There's no shortcut to mastery,\r\nbut we're tricked into thinking there is when a master shares their own methodology.\r\n\r\nThe majority of people following a methodology have 1% of the experience that the\r\nmethodology's author does. And this discrepancy in experience leads to wildly different results\r\ndespite following the same process. To Boris, a man who dreams in C++ and has spent 1/3rd of his\r\nlife in a text editor, Borisgile is the road he uses to drive his software shipping Ferrari on.\r\nBut to your typical programmer, Borisgile is a gloomy path to alcoholism and burnout. There are\r\nsurely aspects of various methodologies we can benefit from, but before we blindly adopt them it's\r\nimportant to ask \"why\". Why am I doing this? What problem does this solve? Does the time spent\r\nfollowing this process outweigh the opportunity cost of not doing other things?\r\n\r\nThere's no rule that says you must follow a single methodology. You won't be punished as a heretic\r\nfor picking the best practices from a handful of methodologies.\r\nYou will not be charged with blasphemy for no longer following a certain methodology when it no\r\nlonger makes sense. Just as you (hopefully) don't unilaterally align with the opinions of a single\r\nideological group, you shouldn't feel obligated to adopt all the practices of a single methodology.\r\nYou should think critically about the problems you have and what processes might help. You should\r\nexperiment with different processes, keep what works, and shamelessly disregard what doesn't.\r\nIgnore those who tell you to \"trust the process\", especially if this \"trust\" requires suspending your\r\nown critical thinking and experiences.\r\n\r\nMany evangelists haven't been successful with the methodology they preach, but they\r\npreach it nonetheless, giving their audience a false sense of confidence in its efficacy. I suspect\r\ntheir willingness to preach something they haven't proven to work for themselves is a consequence of\r\ntheir neomania: an obsession with the new and the false belief that the newer something is, the\r\nbetter it is. From my experience the opposite is true, the older the solution the better. Older\r\nsolutions have withstood the test of time. If something's been used to solve a problem for 30 years\r\nwithout being made obsolete by a superior solution, chances are it'll continue to be in use for\r\nanother 30 years. Take Unix or Democracy for example, chances are they won't be replaced anytime soon.\r\nThese techno-evangelical types preaching methodologies tend to be the same ones constantly\r\nadvocating the use of new frameworks, dev tools, and programming languages. They're more concerned\r\nwith the process than the product. Never forget that you're in the business of making good products,\r\nnot the business of following good processes.\r\n\r\nSoftware is a complex domain that necessitates critical thought. Although methodologies and the\r\nprocesses they advocate can help to tame this complexity, they are not solutions to it. Be extremely\r\nwary of any methodology that takes more time than solving the problem itself. If you spend more time\r\ncreating tickets, planning sprints, and writing design documents than you do building software,\r\nyou've got a big problem. Accept the hard truth that to solve a problem well takes time and effort,\r\nand is almost never achieved on the first attempt. Never lose sight of the ultimate goal: making\r\ngood products.\r\n","title":"The Problem with Software Methodologies","description":"That hip new methodology won't solve all your problems.","date":"2022-04-22","image":"https://raw.githubusercontent.com/Chris-Behan/chris-behan.github.io/master/public/images/boat.jpg"}},"__N_SSG":true}