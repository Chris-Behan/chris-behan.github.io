{"pageProps":{"postData":{"id":"why-you-should-use-typescript","content":"If you're a [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) programmer, you've likely heard of [TypeScript](https://www.typescriptlang.org/).\r\nYou've probably been told you should use it, or how it's the best thing since [sliced bread](https://en.wikipedia.org/wiki/Sliced_bread).\r\nYou may even be working on a codebase that is currently migrating to TypeScript.\r\nBut why?\r\nWhy should you use TypeScript instead of JavaScript?\r\n\r\n\r\nThe answer is that TypeScript helps you detect errors faster and make changes in your code with more confidence.\r\n\r\n## Detect errors faster\r\nPlain old JavaScript is a [dynamically typed language](https://en.wikipedia.org/wiki/Type_system#Dynamic_type_checking_and_runtime_type_information), meaning the data types (ex. string, number, boolean) used in your code are not checked until your code is run.\r\n\"checked\" means to ensure that the operation you are performing on the data type is valid. For example, you cannot call the `toLowerCase()` method on a number, as this will result in a TypeError.\r\n```javascript\r\nconst a = 2;\r\na.toLowerCase()\r\n>>>\r\na.toLowerCase();\r\n  ^\r\nTypeError: a.toLowerCase is not a function\r\n```\r\nIn JavaScript, `TypeError`'s occur when:\r\n* an operand or argument passed to a function is incompatible with the type expected by that operator or function; or\r\n* when attempting to modify a value that cannot be changed; or\r\n* when attempting to use a value in an inappropriate way.\r\n\r\n\r\n\r\nErrors that are not encountered until code is being run are called runtime errors.\r\nRuntime errors are usually detected by unit tests that hit the bug-containing code path, or production code that is run by real users.\r\nThe latter can be extremely difficult to debug and diagnose, especially if you do not have sufficient logging in place to view the context in which the error occurred.\r\n\r\n\r\nTypeScript attempts to remedy the problem of runtime type errors in JavaScript code by adding type declarations and a [static type checker](https://en.wikipedia.org/wiki/Type_system#Static_type_checking).\r\n\r\n\r\nType declarations \"declare\" the data-type of objects and functions in your code.\r\nConsider the following JavaScript function:\r\n```javascript\r\nfunction isEven(n) {\r\n  return n % 2 === 0;\r\n}\r\n```\r\nre-written in TypeScript, this function looks like:\r\n```typescript\r\nfunction isEven(n: number): boolean {\r\n  return n % 2 === 0;\r\n}\r\n```\r\nThe only difference between the two functions is that in the TypeScript version we declare the `n` parameter to be of type `number` and the function itself to return a `boolean`.\r\n\r\nType declarations allow TypeScript to have a static type checker.\r\nA static type checker scans your code to ensure that you are calling all functions and objects with the appropriate types.\r\nFor example, in JavaScript the following code is completely valid:\r\n```javascript\r\nconst a = isEven(\"a\");\r\nconsole.log(a);\r\n>>>\r\nfalse \r\n```\r\n\r\nWhereas in TypeScript, we would get the following error **while** writing our code:\r\n```\r\nindex.ts:5:18 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.\r\n\r\n5 const a = isEven(\"a\");\r\n                   ~~~\r\n\r\n\r\nFound 1 error.\r\n```\r\n\r\nTypeScript's static type checker saves us the time of having to detect type errors with unit tests and reduces the risk of shipping broken code to customers.\r\n\r\n## Change code with confidence\r\n\r\nSuppose you're making changes to the way users are represented in your application.\r\nSpecifically, you are replacing the users `age` property (which is a number) with a `date_of_birth` property (which is a Date object).\r\nYou go into your user creation function:\r\n```javascript\r\nfunction createUser(username, age) {\r\n    const user = {\r\n        username: username,\r\n        id: generateID(),\r\n        age: age\r\n    }\r\n    return user\r\n}\r\n```\r\nand refactor it to:\r\n```javascript\r\nfunction createUser(username, dob) {\r\n    const user = {\r\n        username: username,\r\n        id: generateID(),\r\n        date_of_birth: dob // This line changed\r\n    }\r\n    return user\r\n}\r\n```\r\nYou run your unit tests and they all pass.\r\n\"Damn I'm good\" you say to yourself with pride.\r\nYou put up a merge request and it's reviewed and merged within the hour, \"LGTM, Ship it!\" your reviewer says confidently.\r\n\r\nA few days later, a customer files a bug report complaining that they can't view any adult content despite being well over the age of 18.\r\n\r\nYou immediately investigate the function used to check whether or not a user is an adult:\r\n```javascript\r\nfunction isAdult(user) {\r\n    if (user.age >= 18) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\nAfter 30 minutes of scratching your head in awe, you realize that the function is returning `false` in all scenario's because the `user`'s `age` property is undefined, and in JavaScript `undefined >= 18` evaluates to `false`.\r\n\r\nHad this code been written in TypeScript, we could have created a type alias for our `user` object that describes all the properties and types of a User:\r\n```typescript\r\ntype User = {\r\n    username: string;\r\n    id: string;\r\n    date_of_birth: Date;\r\n}\r\n```\r\n\r\nWe could then have declared the `user` parameter in the `isAdult` function to be of type `User`, which would cause TypeScript's static type checker to have immediately informed us that `user` has no property called `age`.\r\n\r\n```typescript\r\nfunction isAdult(user: User) {\r\n    if (user.age >= 18) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n>>>\r\nindex.ts:19:14 - error TS2339: Property 'age' does not exist on type 'User'.\r\n\r\n19     if (user.age >= 18) {\r\n                ~~~\r\n\r\n\r\nFound 1 error.\r\n```\r\nInstead, we broke functionality for our users and spent time debugging an easily preventable type error.\r\n\r\n## Conclusion\r\nTypeScript is JavaScript with type declarations and a static type checker.\r\nIn exchange for taking the time to declare the types of functions and objects in your code, TypeScript will prevent you from encountering runtime type errors.\r\nWhat this looks like in practice is knowing that you are calling a function with the appropriate parameters, using an object in a permitted way, or whether or not your changes will break the world.\r\n\r\n### Further Reading\r\n[The TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html): An extensive look at TypeScript and its features, I highly recommend starting here.\r\n\r\n[TypeScript-Node Starter repo by Microsoft](https://github.com/microsoft/TypeScript-Node-Starter): Starter code for a basic Node.js express app, written in TypeScript.","title":"Why you should use TypeScript (in 5 minutes)","description":"A five minute explanation as to why you should use TypeScript instead of JavaScript.","date":"2021-05-19"}},"__N_SSG":true}