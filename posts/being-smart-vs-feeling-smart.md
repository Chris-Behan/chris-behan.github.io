---
title: "Being Smart vs. Feeling Smart"
description: "When to be smart, when to feel smart, and the difference."
date: "2022-01-20"
image: "https://raw.githubusercontent.com/Chris-Behan/chris-behan.github.io/master/public/images/cn_tower.jpg"
---

There’s an under-discussed distinction between being smart and feeling smart. We feel smart when we engage in cognitively demanding tasks that require 100% focus. Like when we try to multiple 346 by 789 in our heads. After which our brains are left feeling like they just hit the gym for the first time. “Feeling smart” emphasizes the process. “Being smart” on the other hand is all about outcomes. You use a calculator to multiply 346 by 789, or you round 346 up to 350, 789 up to 800, and approximate. You don’t engage in intellectual dick-shaking to boost your own ego but instead optimize for simplicity, speed, and the best possible outcome.

When it comes to making things, we have a strange tendency to conflate the hardest path with the best path. “If it’s super complex and difficult to build, it probably produces something awesome!” we tell ourselves. We willfully ignore the disastrous track record of overly complex systems in pursuit of the short-term satisfaction that comes from performing mental gymnastics (or as I like to call it “intellectual dick-shaking”). And it’s not until the complexity of the system we build exceeds our own understanding that we realize we’ve fucked up. That’s not to say the best path can’t be hard. I’m sure no matter how you slice it, getting a large spacecraft into orbit is an arduous task. But I am saying we have a peculiar habit of trying to turn everything into rocket science.

In software, feeling smart manifests in one of two ways: a crippling addiction to abstractions or an absolute aversion to them. The abstraction addict has deluded himself into believing that the dependencies he uses aren’t just code written by other mortals, but rather magical black boxes that must be correct. He scoffs at the intern’s suggestion of writing the landing page in HTML and CSS, Instead advocating for the use of a TypeScript React application with 13,494 dependencies. In pursuit of the perfect abstraction, the addict ends up spending all of his time configuring his black boxes and finicking with their dependencies. What could have been done in a collection of python modules, he manages to do with 7 distinct repositories that communicate via HTTP, because directories and function calls are “too coupled”.

The abstraction averse have the opposite problem. They refuse the use of black boxes entirely and attempt to re-write everything from scratch. They have a strong personal affiliation with C/C++ and believe all other languages are for “kiddies”. They admonish the use of garbage collected languages, citing poor performance, and spend weeks re-writing python code in C++. Their re-writes are more performant, in many cases 100x, bringing execution time down from say 10 milliseconds to 100 microseconds. Unfortunately network latency for the application is around 500 milliseconds and the performance gain from their change is not noticeable to the end-user. Yet somehow they manage to see their weeks-long effort that increases the complexity of the system as a win.

This distinction between being smart and feeling smart exists everywhere you use your brain. In social settings, being smart is not taking yourself too seriously, listening intently, and not interrupting others. Being the type of person you’d want to grab a beer with. Feeling smart in social settings is going into gruesome detail on some esoteric concept you’ve just learned, constantly one-upping the stories of everyone else, and self-censoring to ensure you don’t offend anyone. You’ll stretch your memory regurgitating definitions, exercise your creativity embellishing your past, and sharpen your focus by not letting anything of substance slip. But it’ll also be the last time you get invited out for beers.
